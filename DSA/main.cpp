#include <iostream>

#include <ArgoDraft/ConsoleMenu.hpp>
#include <ArgoDraft/ArgoLogger.hpp>

#include "src/Sorting.hpp"

int main() {
    std::cout << "Type `help` for a list of commands" << std::endl;
    // Submenus algorithms and structures
    // Items under algorithms
    // AI Generated list will refine this list later

    // 1. Sorting
    // 1.1 Bubble Sort
    // 1.2 Selection Sort
    // 1.3 Insertion Sort
    // 1.4 Merge Sort
    // 1.5 Quick Sort
    // 1.6 Heap Sort
    // 1.7 Counting Sort
    // 1.8 Radix Sort
    // 1.9 Bucket Sort
    // 1.10 Shell Sort
    // 1.11 Cocktail Sort
    // 1.12 Comb Sort
    // 1.13 Gnome Sort
    // 1.14 Odd-Even Sort
    // 1.15 Stooge Sort
    // 1.16 Pigeonhole Sort
    // 1.17 Cycle Sort
    // 1.18 Bitonic Sort
    // 1.19 Pancake Sort
    // 1.20 Bogo Sort
    // 1.21 Sleep Sort
    // 1.22 Tim Sort
    // 1.23 Intro Sort
    // 1.24 Smooth Sort
    // 1.25 Flash Sort
    // 1.26 Block Sort
    // 1.27 Library Sort
    // 1.28 Strand Sort
    // 1.29 Patience Sort
    // 1.30 Spread Sort
    // 1.31 Cube Sort

    // 2. Searching
    // 2.1 Linear Search
    // 2.2 Binary Search
    // 2.3 Jump Search
    // 2.4 Interpolation Search
    // 2.5 Exponential Search
    // 2.6 Fibonacci Search
    // 2.7 Ternary Search
    // 2.8 Sublist Search
    // 2.9 Search in a sorted and rotated array
    // 2.10 Unbounded Binary Search
    // 2.11 The Ubiquitous Binary Search
    // 2.12 Recursive program to linearly search an element in a given array
    // 2.13 Recursive function to do substring search
    // 2.14 Recursive function to do a simple linear search

    // 3. Graphs
    // 3.1 Breadth First Search
    // 3.2 Depth First Search
    // 3.3 Dijkstra's Algorithm
    // 3.4 Bellman-Ford Algorithm
    // 3.5 Floyd-Warshall Algorithm
    // 3.6 Prim's Algorithm
    // 3.7 Kruskal's Algorithm
    // 3.8 Topological Sort
    // 3.9 Kahn's Algorithm
    // 3.10 Johnson's Algorithm
    // 3.11 Articulation Points (or Cut Vertices) in a Graph
    // 3.12 Bridges in a Graph
    // 3.13 Eulerian Path and Circuit
    // 3.14 Fleury's Algorithm for printing Eulerian Path or Circuit
    // 3.15 Hamiltonian Cycle
    // 3.16 Travelling Salesman Problem
    // 3.17 Chinese Postman Problem
    // 3.18 Strongly Connected Components
    // 3.19 Kosaraju's Algorithm
    // 3.20 Tarjan's Algorithm
    // 3.21 Biconnected Components
    // 3.22 Hopcroft-Karp Algorithm for Maximum Matching
    // 3.23 Edmonds-Karp Algorithm for Maximum Flow
    // 3.24 Ford-Fulkerson Algorithm for Maximum Flow
    // 3.25 Dinic's Algorithm for Maximum Flow
    // 3.26 Push-Relabel Algorithm for Maximum Flow
    // 3.27 Minimum Cut in a Graph
    // 3.28 Network Flow: Push-relabel algorithm
    // 3.29 Network Flow: Dinic's algorithm
    // 3.30 Network Flow: Ford-Fulkerson algorithm
    // 3.31 Network Flow: Edmonds-Karp algorithm
    // 3.32 Network Flow: Push-relabel algorithm
    // 3.33 Network Flow: Minimum Cut in a Graph
    // 3.34 Network Flow: Maximum Flow
    // 3.35 Network Flow: Maximum Bipartite Matching
    // 3.36 Network Flow: Maximum Flow with Vertex Capacities
    // 3.37 Network Flow: Maximum Flow with Edge Capacities
    // 3.38 Network Flow: Maximum Flow with Lower and Upper Bounds

    // 4. Trees
    // 4.1 Binary Search Tree
    // 4.2 AVL Tree
    // 4.3 Red-Black Tree
    // 4.4 Splay Tree
    // 4.5 B-Tree
    // 4.6 B+ Tree
    // 4.7 Trie
    // 4.8 Segment Tree
    // 4.9 Fenwick Tree
    // 4.10 Binary Indexed Tree
    // 4.11 Cartesian Tree
    // 4.12 Suffix Tree
    // 4.13 Suffix Array
    // 4.14 LCP Array
    // 4.15 Threaded Binary Tree
    // 4.16 Huffman Coding
    // 4.17 Huffman Decoding
    // 4.18 Huffman Encoding
    // 4.19 Huffman Tree

    // 5. Strings
    // 5.1 Naive Pattern Searching
    // 5.2 KMP Algorithm
    // 5.3 Rabin-Karp Algorithm
    // 5.4 Finite Automata Algorithm
    // 5.5 Boyer-Moore Algorithm
    // 5.6 Z Algorithm
    // 5.7 Manacher's Algorithm
    // 5.8 Suffix Array
    // 5.9 Suffix Tree
    // 5.10 Suffix Automaton
    // 5.11 Aho-Corasick Algorithm
    // 5.12 Longest Common Prefix Array
    // 5.13 Longest Common Substring
    // 5.14 Longest Common Subsequence
    // 5.15 Longest Palindromic Substring
    // 5.16 Longest Palindromic Subsequence
    // 5.17 Longest Repeated Substring
    // 5.18 Longest Repeated Subsequence
    // 5.19 Longest Repeated Palindromic Substring
    // 5.20 Longest Repeated Palindromic Subsequence
    // 5.21 Longest Common Substring with k mismatches
    // 5.22 Longest Common Subsequence with k mismatches

    // 6. Dynamic Programming
    // 6.1 Longest Increasing Subsequence
    // 6.2 Longest Decreasing Subsequence
    // 6.3 Longest Bitonic Subsequence
    // 6.4 Longest Alternating Subsequence
    // 6.5 Longest Increasing Subarray
    // 6.6 Longest Decreasing Subarray
    // 6.7 Longest Bitonic Subarray
    // 6.8 Longest Alternating Subarray
    // 6.9 Longest Common Subsequence
    // 6.10 Longest Common Substring
    // 6.11 Longest Palindromic Subsequence
    // 6.12 Longest Palindromic Substring
    // 6.13 Longest Repeated Subsequence
    // 6.14 Longest Repeated Substring
    // 6.15 Longest Repeated Palindromic Subsequence

    // 7. Greedy Algorithms
    // 7.1 Activity Selection Problem
    // 7.2 Fractional Knapsack Problem
    // 7.3 Job Sequencing Problem
    // 7.4 Minimum Spanning Tree
    // 7.5 Huffman Coding
    // 7.6 Huffman Decoding
    // 7.7 Huffman Encoding
    // 7.8 Huffman Tree

    // 8. Divide and Conquer
    // 8.1 Binary Search
    // 8.2 Merge Sort
    // 8.3 Quick Sort
    // 8.4 Strassen's Matrix Multiplication
    // 8.5 Closest Pair of Points
    // 8.6 Karatsuba Algorithm
    // 8.7 Fast Fourier Transform
    // 8.8 Cooley-Tukey Fast Fourier Transform
    // 8.9 SchÃ¶nhage-Strassen Algorithm
    // 8.10 Toom-Cook Multiplication
    // 8.11 Master Theorem
    // 8.12 Integer Multiplication
    // 8.13 Integer Division
    // 8.14 Integer Square Root
    // 8.15 Integer Factorization
    // 8.16 Integer GCD
    // 8.17 Integer LCM
    // 8.18 Integer Exponentiation
    // 8.19 Integer Logarithm
    // 8.20 Integer Root
    // 8.21 Integer Factorial
    // 8.22 Integer Fibonacci
    // 8.23 Integer Permutation
    // 8.24 Integer Combination
    // 8.25 Integer Partition
    // 8.26 Integer Subset

    // 9. Bit Manipulation
    // 9.1 Bitwise AND
    // 9.2 Bitwise OR
    // 9.3 Bitwise XOR
    // 9.4 Bitwise NOT
    // 9.5 Bitwise Left Shift
    // 9.6 Bitwise Right Shift
    // 9.7 Bitwise Rotate Left
    // 9.8 Bitwise Rotate Right
    // 9.9 Bitwise Swap
    // 9.10 Bitwise Set
    // 9.11 Bitwise Clear
    // 9.12 Bitwise Toggle
    // 9.13 Bitwise Check
    // 9.14 Bitwise Update
    // 9.15 Bitwise Isolate Rightmost 1
    // 9.16 Bitwise Isolate Rightmost 0
    // 9.17 Bitwise Isolate Rightmost 1 and 0
    // 9.18 Bitwise Isolate Rightmost 1 and 0 and Clear

    // 10. Recursion
    // 10.1 Factorial
    // 10.2 Fibonacci
    // 10.3 Ackermann
    // 10.4 Tower of Hanoi
    // 10.5 Josephus
    // 10.6 Permutation
    // 10.7 Combination
    // 10.8 Subset
    // 10.9 Partition
    // 10.10 Subset Sum
    // 10.11 Coin Change
    // 10.12 Rod Cutting
    // 10.13 Matrix Chain Multiplication
    // 10.14 Longest Common Subsequence
    // 10.15 Longest Common Substring

    // 11. Math
    // 11.1 Prime Numbers
    // 11.2 Prime Factorization
    // 11.3 Prime Factorization using Sieve
    // 11.4 Prime Factorization using Pollard's Rho
    // 11.5 Prime Factorization using Quadratic Sieve
    // 11.6 Prime Factorization using Elliptic Curve
    // 11.7 Prime Factorization using Shor's Algorithm
    // 11.8 Prime Factorization using General Number Field Sieve
    // 11.9 Prime Factorization using AKS Primality Test
    // 11.10 Prime Factorization using Miller-Rabin Primality Test
    // 11.11 Prime Factorization using Fermat's Factorization
    // 11.12 Prime Factorization using Pollard's p-1 Algorithm

    // 12. Geometry
    // 12.1 Point
    // 12.2 Line
    // 12.3 Circle
    // 12.4 Triangle
    // 12.5 Quadrilateral
    // 12.6 Polygon
    // 12.7 Convex Hull
    // 12.8 Line Intersection
    // 12.9 Circle Intersection
    // 12.10 Triangle Intersection
    // 12.11 Quadrilateral Intersection
    // 12.12 Polygon Intersection
    // 12.13 Convex Hull Intersection
    // 12.14 Line Reflection
    // 12.15 Circle Reflection
    // 12.16 Triangle Reflection
    // 12.17 Quadrilateral Reflection
    // 12.18 Polygon Reflection
    // 12.19 Convex Hull Reflection
    // 12.20 Line Rotation
    // 12.21 Circle Rotation
    // 12.22 Triangle Rotation
    // 12.23 Quadrilateral Rotation
    // 12.24 Polygon Rotation
    // 12.25 Convex Hull Rotation
    // 12.26 Line Translation
    // 12.27 Circle Translation
    // 12.28 Triangle Translation
    // 12.29 Quadrilateral Translation
    // 12.30 Polygon Translation
    // 12.31 Convex Hull Translation
    // 12.32 Line Scaling
    // 12.33 Circle Scaling
    // 12.34 Triangle Scaling
    // 12.35 Quadrilateral Scaling
    // 12.36 Polygon Scaling
    // 12.37 Convex Hull Scaling
    // 12.38 Line Shearing
    // 12.39 Circle Shearing
    // 12.40 Triangle Shearing
    // 12.41 Quadrilateral Shearing
    // 12.42 Polygon Shearing
    // 12.43 Convex Hull Shearing
    // 12.44 Line Reflection
    // 12.45 Circle Reflection
    // 12.46 Triangle Reflection
    // 12.47 Quadrilateral Reflection
    // 12.48 Polygon Reflection
    // 12.49 Convex Hull Reflection

    // 13. Combinatorics
    // 13.1 Permutation
    // 13.2 Combination
    // 13.3 Subset
    // 13.4 Partition
    // 13.5 Subset Sum
    // 13.6 Coin Change
    // 13.7 Rod Cutting

    // 14. Probability
    // 14.1 Probability of an Event
    // 14.2 Probability of a Random Variable
    // 14.3 Probability of a Random Process
    // 14.4 Probability of a Random Distribution
    // 14.5 Probability of a Random Function
    // 14.6 Probability of a Random Algorithm
    // 14.7 Probability of a Random Data Structure
    // 14.8 Probability of a Random Problem
    // 14.9 Probability of a Random Solution
    // 14.10 Probability of a Random Program
    // 14.11 Probability of a Random System
    // 14.12 Probability of a Random Network
    // 14.13 Probability of a Random Graph
    // 14.14 Probability of a Random Tree
    // 14.15 Probability of a Random String
    // 14.16 Probability of a Random Sequence
    // 14.17 Probability of a Random Matrix
    // 14.18 Probability of a Random Set
    // 14.19 Probability of a Random Multiset

    // 15. Game Theory
    // 15.1 Nim Game
    // 15.2 Grundy Numbers
    // 15.3 Sprague-Grundy Theorem
    // 15.4 Minimax Algorithm
    // 15.5 Alpha-Beta Pruning
    // 15.6 Negamax Algorithm
    // 15.7 Monte Carlo Tree Search
    // 15.8 AlphaGo Algorithm
    // 15.9 AlphaZero Algorithm
    // 15.10 AlphaStar Algorithm
    // 15.11 AlphaFold Algorithm
    // 15.12 AlphaChem Algorithm
    // 15.13 AlphaCurl Algorithm

    // 16. Data Structures
    // 16.1 Array
    // 16.2 Linked List
    // 16.3 Stack
    // 16.4 Queue
    // 16.5 Deque
    // 16.6 Priority Queue
    // 16.7 Heap
    // 16.8 Hash Table
    // 16.9 Set
    // 16.10 Multiset
    // 16.11 Map
    // 16.12 Multimap
    // 16.13 Tree
    // 16.14 Binary Tree
    // 16.15 Binary Search Tree
    // 16.16 AVL Tree
    // 16.17 Red-Black Tree
    // 16.18 Splay Tree
    // 16.19 B-Tree
    // 16.20 B+ Tree
    // 16.21 Trie
    // 16.22 Segment Tree
    // 16.23 Fenwick Tree
    // 16.24 Binary Indexed Tree
    // 16.25 Cartesian Tree
    // 16.26 Suffix Tree
    // 16.27 Suffix Array
    // 16.28 LCP Array
    // 16.29 Threaded Binary Tree
    // 16.30 Huffman Tree


    try {
        ArgoDraft::MainMenu menu;
        ArgoDraft::Menu algorithmsSubMenu("algorithms", "Examples of various algorithms");
        ArgoDraft::Menu structuresSubMenu("structures", "Examples of various data structures");

        algorithmsSubMenu.AddAction({
            "Bubble Sort", "Sorts an array using the Bubble Sort algorithm",
            []() {
                const Sorting sorting;
                sorting.bubbleSort();
            },
            {"bubble", "Bubble", "bubblesort", "BubbleSort"}
        });

        algorithmsSubMenu.AddAction({
            "Selection Sort", "Sorts an array using the Selection Sort algorithm",
            []() {
                const Sorting sorting;
                sorting.selectionSort();
            },
            {"selection", "Selection", "selectionsort", "SelectionSort"}
        });

        algorithmsSubMenu.AddAction({
            "Insertion Sort", "Sorts an array using the Insertion Sort algorithm",
            []() {
                const Sorting sorting;
                sorting.insertionSort();
            },
            {"insertion", "Insertion", "insertionsort", "InsertionSort"}
        });

        

        menu.AddMenu(algorithmsSubMenu);
        menu.AddMenu(structuresSubMenu);

        menu.Init();
    } catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
